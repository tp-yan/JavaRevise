<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=unicode">

<body class="wiz-editor-body" spellcheck="false" style="opacity: 1;" ><div>P24-25</div><div>Linux中的内存分为：1.内核空间 2.用户空间。</div><div>应用程序进程占用的内存在用户空间。</div><div>Linux进程的地址空间：</div><div class="wiz-table-container" style="position: relative; padding: 0px;"><div class="wiz-table-body"><table style="width: 229px;"><tbody><tr><td align="left" valign="middle" style="width: 228px;" class="">操作系统<span>（高地址）</span></td></tr><tr><td align="left" valign="middle" style="width: 228px;" class="" rowspan="3" colspan="1">栈（自顶向下扩展）</td></tr><tr></tr><tr></tr><tr><td align="left" valign="middle" style="width: 228px;" class="">....</td></tr><tr><td align="left" valign="middle" style="width: 228px;" class="">堆<span>（自底向上</span><span><span>扩展</span></span><span>）</span></td></tr><tr><td align="left" valign="middle" style="width: 228px;" class="">数据段</td></tr><tr><td style="width: 228px;" class="">代码段（低地址）</td></tr></tbody></table></div></div><div>(1)栈：<b>由操作系统自动分配和释放</b>，用于<b>维护函数调用上下文</b>，<b>存储函数的参数值、局部变量等</b>。使用一级缓存，速度较快。</div><div>(2)堆：应用程序<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">动态</span>分配的内存区域。一般有<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">程序员分配和释放(C/C++)</span>，在Java中由JVM的垃圾回收机制自动释放。使用二级缓存，速度较慢。</div><div>(3)数据段：存放程序数据，包括未初始化数据段和初始化数据段？</div><div>(4)代码段：存放程序代码，具有执行权限，只读。</div><div>P26</div><div><b>栈帧(stack frame):</b>保存了一个函数调用的所有相关信息，维护从函数调用到结束的过程。（栈帧作为一个整体单位出入栈）。</div><div>栈帧内容：</div><div>1.函数参数</div><div>2.函数返回地址，前一个栈帧的指针，存储了恢复前一个栈帧所必须的数据？</div><div>3.函数的局部变量</div><div>4.保存调用时的上下文环境(寄存器相关内容)</div><div>栈帧结构：</div><div class="wiz-table-container" style="position: relative; padding: 0px;"><div class="wiz-table-body"><table style="width: 390px;"><tbody><tr><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width: 149px;" class="">参数n</td><td align="left" valign="middle" style="width: 121px;" class="">函数实参</td></tr><tr style="height: 33px;"><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width: 149px;" class="">...</td><td align="left" valign="middle" style="width: 121px;"><br></td></tr><tr><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width: 149px;" class=""><span>参数1</span><br></td><td align="left" valign="middle" style="width: 121px;"><br></td></tr><tr><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width: 149px;" class="">函数返回地址</td><td align="left" valign="middle" style="width: 121px;" class="">恢复前一个</td></tr><tr><td align="left" valign="middle" style="width:120px" class=""><span>ebp→</span><br></td><td align="left" valign="middle" style="width: 149px;" class="">旧的ebp值</td><td align="left" valign="middle" style="width: 121px;" class="">栈帧的数据</td></tr><tr><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width: 149px;" class="">保存的寄存器</td><td align="left" valign="middle" style="width: 121px;" class="">即保存调用时的上下文环境</td></tr><tr><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width: 149px;" class="">局部变量1</td><td align="left" valign="middle" style="width: 121px;" class="">函数局部变量</td></tr><tr><td style="width: 120px;"><br></td><td class="" style="width: 149px;">...</td><td style="width: 121px;"><br></td></tr><tr><td align="left" valign="middle" style="width:120px"><br></td><td style="width: 149px;" class=""><span>局部变量n</span><br></td><td style="width: 121px;"><br></td></tr><tr><td align="left" valign="middle" style="width:120px" class="">esp→</td><td style="width: 149px;" class="">其他数据</td><td style="width: 121px;"><br></td></tr></tbody></table></div></div><div>一个栈帧维护了2个指针：ebp与esp寄存器。</div><div>ebp：栈帧指针，指向函数栈帧(内)的一个固定位置，不随函数的执行变化。用来唯一标识一个栈帧的位置(类似于函数栈帧的索引)，比如<span>旧的ebp值作用：当前函数结束时，找到调用函数的栈帧，从而找到调用函数相关信息，同时结束的函数栈帧也销毁了。</span></div><div>esp：栈帧栈顶指针，始终指定栈顶，随函数执行变化。</div><div><span>函数返回地址：函数结束后要执行的下一条指令地址。</span><br></div><div><span>P27</span></div><div>堆内存：堆的空间比栈大得多，而且都是动态分配的，大量使用new，delete，free会造成堆内存中容易出现内存碎片。</div><div>C++动态分配与删除堆内存：new--delete，malloc--free，<b><span>程序员</span>必须主动释放</b>。在Java中则由JVM自动回收。</div><div>P28</div><div><b>Java内存分区</b></div><div class="wiz-table-container" style="position: relative; padding: 0px;"><div class="wiz-table-body"><table style="width: 487px;"><tbody><tr><td align="left" valign="middle" style="width: 127px; background-color: rgb(247, 182, 255);" class="" rowspan="4" colspan="1">Java堆内存</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(172, 243, 254);" class="" rowspan="1" colspan="2">线程1</td><td align="left" valign="middle" style="width:120px" class="">...</td><td align="left" valign="middle" style="width:120px" class="">线程n</td></tr><tr><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">Java虚拟机栈</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="">本地方法栈</td><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width:120px"><br></td></tr><tr><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">栈帧1</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class=""><br></td><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width:120px"><br></td></tr><tr><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">...</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class=""><br></td><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width:120px"><br></td></tr><tr><td align="left" valign="middle" style="width: 127px; background-color: rgb(254, 244, 156);" class="">方法区</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">栈帧n</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class=""><br></td><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width:120px"><br></td></tr><tr><td align="left" valign="middle" style="width: 127px; background-color: rgb(254, 244, 156);" class="">运行时常量池1</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class=""><br></td><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class=""><br></td><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width:120px"><br></td></tr><tr><td align="left" valign="middle" style="width: 127px; background-color: rgb(254, 244, 156);" class="">...</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class=""><br></td><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class=""><br></td><td align="left" valign="middle" style="width:120px"><br></td><td align="left" valign="middle" style="width:120px"><br></td></tr><tr><td style="width: 127px; background-color: rgb(254, 244, 156);" class=""><span style="background-color: rgb(255, 255, 255);">运行时常量</span><span style="background-color: rgb(255, 255, 255);"><span>池</span></span><span style="background-color: rgb(255, 255, 255);">n</span><br></td><td style="width: 120px; background-color: rgb(172, 243, 254);" class="" rowspan="1" colspan="2" align="center">程序计数器</td><td style="width: 120px;" class=""><br></td><td align="left" valign="middle" style="width:120px" class=""><br></td></tr></tbody></table></div></div><div>Java堆内存与方法区是线程共享的数据区。</div><div>(1)Java堆内存：JVM管理的最大内存区域，<b>几乎所有的对象实例(new生成的对象)和数组在这里分配内存</b>。是垃圾收集器管理的主要区域。</div><div><span>Java堆内存分为"新生代"和"老生代"，主要使JVM能更好管理内存中的对象。</span><br></div><div>"新生代"：Eden区、From Survivor区、To Survivor区。</div><div>(2)方法区：<b>存储类信息、运行时常量、静态变量</b>等。垃圾回收<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">很少光顾这里</span>。</div><div>运行时常量池：存放编译期生成的<b>各种字面量和符号引用</b>。</div><div>(3)程序计数器：记录正在执行的虚拟机字节码的地址。用于JVM切换线程时恢复到对应线程的执行位置。</div><div>(4)Java虚拟机栈：对应<b>Java中的栈内存，为线程私有</b>。生命周期与线程相同，主要存储函数的局部变量，包括各种基本数据类型和引用类型（<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">对象本身是存储在内存中的</span>），这些局部变量存在函数对应的栈帧中，作用域为函数。</div><div>(5)本地方法栈：<b>执行的是Native方法服务</b>，而Java虚拟机栈执行的是Java方法。</div><div>P34</div><div>栈与堆内存都会溢出，在Java中，栈溢出：StackOverflowError；堆溢出：OutOfMemoryError.</div><div>P40 Java中的引用与C/C++中的指针区别</div><div>共同点：都是存的地址。Java引用存的是对象在堆内存中的地址，而引用本身是在栈内存。指针也是存的地址，在栈内存或堆内存(使用new、malloc)。</div><div>区别：</div><div>Java中的引用只能操作其引用的对象，或者指向其他任意一个类型符合的对象。</div><div>而指针可以进行算术和比较运算，如加减操作，赋任意值，可以指向内存空间的任意操作系统允许的地址。</div><div>P45-48</div><div>Java的垃圾回收机制：</div><div>回收机制：<b>当一个对象没有任何引用指向它时被回收</b>。</div><div>回收实现方法：<b>引用计数法</b>。</div><div><ul><li><span style="line-height: 1.7;">每当new一个新对象时，就分配一个变量存储</span><span style="line-height: 1.7;">该对象的</span><span style="line-height: 1.7;">引用个数，即引用计数器，初始值为1。</span><br></li><li><span style="line-height: 1.7;">当其他变量引用该对象时，计数器+1；</span><br></li><li><span style="line-height: 1.7;">当引用超过生命周期或被设为另一个值时，计数器-1；</span><br></li><li><span style="line-height: 1.7;">任何计数器为0的对象都可以被回收。</span><br></li><li><span style="line-height: 1.7;">当一个对象实例被回收时，它引用的所有对象实例的计数器-1；</span><br></li></ul></div><div>以上方法最大问题：<b>无法检测循环引用</b>问题。</div><div>如下示例：<br>class A{&nbsp; &nbsp;&nbsp;<span style="line-height: 1.7;">public A neighbour;</span><span style="line-height: 1.7;">&nbsp; &nbsp;&nbsp;</span><span style="line-height: 1.7;">}</span></div><div><span style="line-height: 1.7;">pulic class Code{</span><br></div><div>pulic static void main(String[] args){</div><div>&nbsp; &nbsp; A obj1 = new A();<br></div><div>&nbsp; &nbsp; A&nbsp;<span>obj2 = new A();</span><br></div><div>&nbsp; &nbsp; obj1.<span>neighbour = obj2;</span><span><br></span></div><div><span style="line-height: 1.7;">&nbsp; &nbsp;&nbsp;</span><span><span>obj2.</span></span><span><span>neighbour = obj1;</span></span><span><br></span></div><div>&nbsp; &nbsp; obj1 = obj2 = null;<span><span><br></span></span></div><div>}<span style="line-height: 1.7;">}</span></div><div>问题：对象1、2的计数器都不为0，但是<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">都无法再被调用，也不能被回收！</span></div><div class="wiz-table-container" style="position: relative; padding: 0px;"><div class="wiz-table-body"><table style="width: 480px;"><tbody><tr><td align="center" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="">栈内存</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="" rowspan="1" colspan="3">堆内存</td></tr><tr><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="">obj1</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="" rowspan="1" colspan="3">对象1</td></tr><tr><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="">obj2</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class=""><br></td><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">↑↓</td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class=""><br></td></tr><tr><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class=""><br></td><td align="center" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="" rowspan="1" colspan="3"><span>对象2</span><br></td></tr></tbody></table></div></div><div>解决方法：<b>可达性分析</b>。</div><div>代表：根搜索算法，一种对象引用遍历算法。</div><div>原理：垃圾回收机制<b>将所有引用看成一张图</b>，对象引用遍历<b>从一组对象(即根对象)开始</b>，沿着<b>对象图</b>的每条路径，<b>递归</b>确定可达的对象，遍历阶段标记可达对象(称为标记对象)。标记阶段后进行清理：如果某对象不能从这些根对象的一个到达，则被当做垃圾回收。</div><div><span style="line-height: 1.7;">根搜索例子：obj3~5尽管互相关联，但无法从root集合达到，属于可回收对象。</span><br></div><div class="wiz-table-container" style="position: relative; padding: 0px;"><div class="wiz-table-body"><table style="width: 600px;"><tbody><tr><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="" rowspan="1" colspan="5">root(根对象集合)</td></tr><tr><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="">obj1</td><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">obj3</td><td align="left" valign="middle" style="width:120px" class=""><br></td></tr><tr><td align="left" valign="middle" style="width: 120px; background-color: rgb(255, 199, 200);" class="">obj2</td><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">obj4</td><td align="left" valign="middle" style="width:120px" class=""><br></td><td align="left" valign="middle" style="width: 120px; background-color: rgb(178, 255, 161);" class="">obj5</td></tr><tr><td align="center" valign="middle" style="width:120px" class="" rowspan="2" colspan="5"><span>根搜索算法例子</span><br></td></tr><tr></tr></tbody></table></div></div><div>根对象包括：</div><div>1. 虚拟机栈(栈帧中的本地变量表)中引用的对象。</div><div>2. 方法区中类静态属性引用的对象。</div><div>3. 方法区中常量引用的对象。</div><div>4. 本地方法栈中JNI(Java Native Interface)引用的对象。</div><div>P50</div><div>Java中参数传入基本数据类型或者引用类型都是值传递，即产生了一个该基本类型或者引用类型的副本，是新的变量。</div><div><br></div><div><br></div></body></html>